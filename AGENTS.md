# AGENTS.md - Context for Cloud-Based LLM Agents

This file provides essential context for cloud-based LLM agents working on the Metabolistic3D project. Use this as a reference for understanding the project structure, patterns, and best practices.

## Project Overview

**Metabolistic3D** is a 3D cellular metabolism simulation game built with the Bevy engine. It simulates real cellular biochemistry through interconnected metabolic blocks that mirror biological processes like glycolysis, respiration, and photosynthesis.

### Core Concept
- Players manage metabolic pathways in a 3D cellular environment
- Balance energy production (ATP), reducing power (NADH/NADPH), and resource management
- Educational gameplay that teaches real biochemistry concepts
- Self-contained metabolic blocks with minimal cross-talk via generic "currencies"

## Technology Stack

- **Engine**: [Bevy 0.15](https://bevyengine.org/) - Modern ECS-based game engine
- **Physics**: [Avian3D 0.2.1](https://github.com/Jondolf/avian) - 3D physics simulation
- **Input**: [Leafwing Input Manager 0.16](https://github.com/Leafwing-Studios/leafwing-input-manager)
- **Debug/Dev Tools**: 
  - bevy-inspector-egui 0.30.0 (runtime inspection)
  - bevy_egui 0.33.0 (immediate mode GUI)
  - bevy_dev_tools (development utilities)

## Project Architecture

### Build Profiles
- **Development** (`cargo run`): Fast compilation, hot reloading, debug tools
- **Release** (`cargo build --release`): Web-optimized, size-focused
- **Release Native** (`cargo build --profile release-native`): Desktop-optimized performance

### Feature Flags
- `full`: Graphics, audio, UI dependencies (default for development)
- `headless`: Minimal features, no graphics/audio (for testing/simulation)
- `dev_native`: Development with file watchers and hot reloading

### Directory Structure
```
src/
├── main.rs           # Application entry point and setup
├── lib.rs            # Library root
├── camera.rs         # Camera systems and controls
├── debug.rs          # Debug utilities and visualization
├── dev_tools.rs      # Development tools and helpers
├── inspector.rs      # Runtime inspection systems
├── molecules.rs      # Molecular entities and chemistry systems
├── shared.rs         # Shared utilities and components
├── blocks/           # Primary metabolistic processing blocks
    ├── genome.rs     # Manages the cell genome (state of expression of other blocks)
├── player/           # Player controller and movement systems
├── scenes/           # Scene management (menu, 2D, 3D scenes)
└── terrain/          # Terrain generation and management
```

## Key Development Patterns

### Bevy ECS Architecture
- **Entities**: Game objects (metabolic blocks, molecules, player)
- **Components**: Data (Position, Velocity, MetabolicRate)
- **Systems**: Logic functions that operate on entities with specific components
- **Resources**: Global state (GameState, InputManager, Camera)

### Metabolic Block Design
Each metabolic block follows these principles:
- **Self-contained**: Can run independently once it has feedstocks
- **Minimal cross-talk**: Communicates via standardized "currencies"
- **Clear thematic focus**: Each block has distinct gameplay feel

### Currency System
Core metabolic currencies that flow between blocks:
- **ATP**: Energy currency (generated by Light Capture, Respiration, Fermentation)
- **Reducing Power**: NADH/NADPH for biosynthesis
- **Acetyl-CoA**: Carbon backbone for lipid synthesis
- **Carbon Skeletons**: Building blocks for amino acids, nucleotides

## Development Guidelines

### Code Style
- Follow Rust conventions and `rustfmt` formatting
- Use descriptive names for systems and components
- Prefer composition over inheritance (ECS paradigm)
- Document public APIs and complex logic

### System Organization
- Group related systems into plugins
- Use `Startup` systems for initialization
- Use `Update` systems for game logic
- Use `FixedUpdate` for physics-dependent logic
- Leverage state management for scene transitions

### Resource Management
- Use Bevy's asset system for loading models, textures, sounds
- Implement hot reloading for development builds
- Optimize asset loading for web deployment

### Testing Strategy
- Unit tests for pure functions and calculations
- Integration tests in `tests/` directory
- Use headless feature for automated testing
- Test metabolic pathway calculations separately from rendering

## Common Tasks and Patterns

### Adding a New Metabolic Block
1. Define components for the block's state and properties
2. Create systems for the block's internal logic
3. Implement currency input/output systems
4. Add visual representation (3D model, particle effects)
5. Create interaction systems for player control
6. Add to the appropriate plugin structure

### Debugging and Development
- Use `F12` to open inspector in development builds
- Enable physics debugging with gizmos
- Use `tracing` macros for logging (`info!`, `warn!`, `error!`)
- Leverage hot reloading for rapid iteration

### Performance Considerations
- Use `Query` filters to avoid unnecessary system runs
- Implement LOD (Level of Detail) for complex metabolic visualizations
- Consider using `ParallelCommands` for batch operations
- Profile with Bevy's built-in diagnostic tools

## File References for Context

- **[README.md](README.md)**: Build instructions and quick start guide
- **[BEVYCONTEXT.md](BEVYCONTEXT.md)**: Comprehensive Bevy engine API reference
- **[Summary.md](Summary.md)**: Game design document with metabolic block specifications
- **[Cargo.toml](Cargo.toml)**: Dependencies and build configuration

## Best Practices for LLM Agents

### When Making Changes
1. **Read existing code patterns** before implementing new features
2. **Maintain consistency** with established naming conventions
3. **Test changes** in development mode before suggesting release builds
4. **Consider performance implications** of new systems or components
5. **Update documentation** when adding new metabolic blocks or systems

### Code Quality
- Prefer small, focused functions over large monolithic systems
- Use Bevy's query system efficiently (avoid unnecessary `Entity` iteration)
- Implement error handling for asset loading and system failures
- Follow the principle of least privilege for mutable access

This context should help you understand the project architecture and contribute effectively to the Metabolistic3D codebase. 